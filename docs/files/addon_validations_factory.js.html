<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>addon/validations/factory.js - Ember CP Validations</title>
    <meta name="description" content="Ember computed property based validations">
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/css/custom.css">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap.css">
    <link rel="stylesheet" href="../assets/vendor/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="../assets/css/theme.css">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300,400,500,600,700' rel='stylesheet' type='text/css'>
    
</head>
<body>
    <nav class="navbar navbar-default">
      <div class="container-fluid">
        <div class="navbar-header">
          <a href="../" class="navbar-brand">
            <img src="../assets/img/ember-logo.png" alt="">
            <span>CP Validations</span>
          </a>
        </div>

        <div class="collapse navbar-collapse" id="nav">
          <ul class="nav navbar-nav navbar-right">
            <li><a href="https://github.com/offirgolan/ember-cp-validations" class="fa fa-github github"></a></li>
          </ul>
        </div>
      </div>
    </nav>
    <div id="main-wrapper" class="row">
        <div id="content-wrapper">
            <ol class="panel-group" id="sidebar" role="tablist" aria-multiselectable="true">
                <li class="panel panel-default">
                    <div class="panel-heading" role="tab" id="sidebar-search-heading">
                        <h4 class="panel-title">
                      <a role="button" data-toggle="collapse" href="#sidebar-search" aria-expanded="true" aria-controls="collapseOne">
                        Search
                      </a>
                    </h4>
                    </div>
                    <div id="sidebar-search" class="panel-collapse collapse in" role="tabpanel" aria-labelledby="sidebar-search-heading">
                        <div class="panel-body">
                            <div id="api-tabview-filter">
                                <input type="search" id="api-filter" placeholder="Search...">
                            </div>
                        </div>
                    </div>
                </li>
                    <li class="panel panel-default">
                        <div class="panel-heading" role="tab" id="sidebar-version-heading">
                            <h4 class="panel-title">
                                <a role="button" href="https://github.com/offirgolan/ember-cp-validations/commits/v3.1.4" target="_blank">
                                  Tag: v3.1.4
                                </a>
                            </h4>
                        </div>
                    </li>
                <li class="panel panel-default">
                    <div class="panel-heading" role="tab" id="sidebar-modules-heading">
                        <h4 class="panel-title">
                    <a role="button" data-toggle="collapse" href="#sidebar-modules" aria-expanded="true" aria-controls="collapseOne">
                      Modules
                    </a>
                  </h4>
                    </div>
                    <div id="sidebar-modules" class="panel-collapse collapse in" role="tabpanel" aria-labelledby="sidebar-modules-heading">
                        <div class="panel-body">
                                <ol>
                                        <li>
                                            <a href="../modules/Templating.html">Templating</a>
                                                    <li class="sub"><a href="../modules/V-Get Helper.html">V-Get Helper</a></li>
                                        </li>
                                        <li>
                                            <a href="../modules/Usage.html">Usage</a>
                                                    <li class="sub"><a href="../modules/Basic.html">Basic</a></li>
                                                    <li class="sub"><a href="../modules/Advanced.html">Advanced</a></li>
                                                    <li class="sub"><a href="../modules/I18n Solutions.html">I18n Solutions</a></li>
                                        </li>
                                        <li>
                                            <a href="../modules/Validations.html">Validations</a>
                                                    <li class="sub"><a href="../modules/Accessing Validations.html">Accessing Validations</a></li>
                                        </li>
                                        <li>
                                            <a href="../modules/Validators.html">Validators</a>
                                                    <li class="sub"><a href="../modules/Common Options.html">Common Options</a></li>
                                        </li>
                                </ol>
                        </div>
                    </div>
                </li>
            
                <li class="panel panel-default">
                    <div class="panel-heading" role="tab" id="sidebar-classes-heading">
                        <h4 class="panel-title">
                      <a role="button" data-toggle="collapse" href="#sidebar-classes" aria-expanded="true" aria-controls="collapseOne">
                        Classes
                      </a>
                    </h4>
                    </div>
                    <div id="sidebar-classes" class="panel-collapse collapse in" role="tabpanel" aria-labelledby="sidebar-classes-heading">
                        <div class="panel-body">
                            <ol>
                                    <li>
                                        <a href="../classes/Alias.html">Alias</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Base.html">Base</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Belongs To.html">Belongs To</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Collection.html">Collection</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Confirmation.html">Confirmation</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Custom.html">Custom</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Date.html">Date</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Dependent.html">Dependent</a>
                                    </li>
                                    <li>
                                        <a href="../classes/DS Error.html">DS Error</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Error.html">Error</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Exclusion.html">Exclusion</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Factory.html">Factory</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Format.html">Format</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Has Many.html">Has Many</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Inclusion.html">Inclusion</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Inline.html">Inline</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Length.html">Length</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Messages.html">Messages</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Number.html">Number</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Presence.html">Presence</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Result.html">Result</a>
                                    </li>
                                    <li>
                                        <a href="../classes/ResultCollection.html">ResultCollection</a>
                                    </li>
                            </ol>
                        </div>
                    </div>
                </li>
            </ol>
            <div class="content-container">
                <div class="apidocs">
                    <div id="docs-main">
                        <div class="content">
<div class="page-header">
    <h1><i class="fa fa-file-code-o" aria-hidden="true"></i> addon/validations/factory.js File</h1>
</div>

<div class="file">
    <pre class="prettyprint linenums">
/**
 * Copyright 2016, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */

import Ember from &#x27;ember&#x27;;
import flatten from &#x27;../utils/flatten&#x27;;
import assign from &#x27;../utils/assign&#x27;;
import ValidationResult from &#x27;../-private/result&#x27;;
import ResultCollection from &#x27;./result-collection&#x27;;
import BaseValidator from &#x27;../validators/base&#x27;;
import cycleBreaker from &#x27;../utils/cycle-breaker&#x27;;
import shouldCallSuper from &#x27;../utils/should-call-super&#x27;;
import { isDsModel, isValidatable, isPromise, mergeOptions } from &#x27;../utils/utils&#x27;;

const {
  get,
  set,
  run,
  RSVP,
  isNone,
  guidFor,
  isEmpty,
  isArray,
  computed,
  getOwner,
  makeArray,
  getWithDefault,
  A: emberArray
} = Ember;

const merge = Ember.assign || Ember.merge;

const {
  Promise
} = RSVP;

/**
 * ## Running Manual Validations
 *
 * Although validations are lazily computed, there are times where we might want to force all or
 * specific validations to happen. For this reason we have exposed three methods:
 *
 * - {{#crossLink &quot;Factory/validateSync:method&quot;}}{{/crossLink}}: Should only be used if all validations are synchronous. It will throw an error if any of the validations are asynchronous
 * - {{#crossLink &quot;Factory/validate:method&quot;}}{{/crossLink}}: Will always return a promise and should be used if asynchronous validations are present
 * - {{#crossLink &quot;Factory/validateAttribute:method&quot;}}{{/crossLink}}: A functional approach to validating an attribute without changing its state
 *
 * @module Validations
 * @main Validations
 */

/**
 * All validations can be accessed via the &#x60;validations&#x60; object created on your model/object.
 * Each attribute also has its own validation which has the same properties.
 * An attribute validation can be accessed via &#x60;validations.attrs.&lt;ATTRIBUTE&gt;&#x60; which will return a {{#crossLink &quot;ResultCollection&quot;}}{{/crossLink}}.
 *
 * ### Global Validations
 *
 * Global validations exist on the &#x60;validations&#x60; object that resides on the object that is being validated.
 * To see all possible properties, please checkout the docs for {{#crossLink &quot;ResultCollection&quot;}}{{/crossLink}}.
 *
 * &#x60;&#x60;&#x60;js
 * model.get(&#x27;validations.isValid&#x27;);
 * model.get(&#x27;validations.errors&#x27;);
 * model.get(&#x27;validations.messages&#x27;);
 * // etc...
 * &#x60;&#x60;&#x60;
 *
 * ### Attribute Validations
 *
 * The &#x60;validations&#x60; object also contains an &#x60;attrs&#x60; object which holds a {{#crossLink &quot;ResultCollection&quot;}}{{/crossLink}}
 * for each attribute specified in your validation rules.
 *
 * &#x60;&#x60;&#x60;js
 * model.get(&#x27;validations.attrs.username.isValid&#x27;);
 * model.get(&#x27;validations.attrs.password.errors&#x27;);
 * model.get(&#x27;validations.attrs.email.messages&#x27;);
 * // etc...
 * &#x60;&#x60;&#x60;
 * @module Validations
 * @submodule Accessing Validations
 */

/**
 * @module Validations
 * @class Factory
 */

/**
 * Top level method that will ultimately return a mixin with all CP validations
 *
 * @method  buildValidations
 * @param  {Object} validations  Validation rules
 * @return {Ember.Mixin}
 */
export
default

function buildValidations(validations = {}, globalOptions = {}) {
  normalizeOptions(validations, globalOptions);

  let Validations, validationMixinCount;

  let ValidationsMixin = Ember.Mixin.create({
    init() {
      this._super(...arguments);

      // Count number of mixins to bypass super check if there is more than 1
      this.__validationsMixinCount__ = this.__validationsMixinCount__ || 0;
      validationMixinCount = ++this.__validationsMixinCount__;
    },
    __validationsClass__: computed(function() {
      if (!Validations) {
        let inheritedClass;

        if (shouldCallSuper(this, &#x27;__validationsClass__&#x27;) || validationMixinCount &gt; 1) {
          inheritedClass = this._super();
        }

        Validations = createValidationsClass(inheritedClass, validations, this);
      }
      return Validations;
    }).readOnly(),
    validations: computed(function() {
      return this.get(&#x27;__validationsClass__&#x27;).create({ model: this });
    }).readOnly(),
    validate() {
      return get(this, &#x27;validations&#x27;).validate(...arguments);
    },
    validateSync() {
      return get(this, &#x27;validations&#x27;).validateSync(...arguments);
    },
    validateAttribute() {
      return get(this, &#x27;validations&#x27;).validateAttribute(...arguments);
    },
    destroy() {
      this._super(...arguments);
      get(this, &#x27;validations&#x27;).destroy();
    }
  });

  // Label mixin under a named scope for Ember Inspector
  ValidationsMixin[Ember.NAME_KEY] = &#x27;Validations&#x27;;

  return ValidationsMixin;
}

/**
 * Validation rules can be created with default and global options
 * {
 *   description: &#x27;Username&#x27;,
 *   validators: [...]
 * }
 *
 * This method generate the default options pojo, applies it to each validation rule, and flattens the object
 *
 * @method normalizeOptions
 * @private
 * @param  {Object} validations
 * @return
 */
function normalizeOptions(validations = {}, globalOptions = {}) {
  let validatableAttrs = Object.keys(validations);

  validatableAttrs.forEach((attribute) =&gt; {
    let rules = validations[attribute];

    if (rules &amp;&amp; typeof rules === &#x27;object&#x27; &amp;&amp; isArray(rules.validators)) {
      let options = Object.keys(rules).reduce((o, k) =&gt; {
        if (k !== &#x27;validators&#x27;) {
          o[k] = rules[k];
        }
        return o;
      }, {});

      let { validators } = rules;
      validators.forEach((v) =&gt; {
        v.defaultOptions = options;
      });
      validations[attribute] = validators;
    }
    validations[attribute] = makeArray(validations[attribute]);
    validations[attribute].forEach((v) =&gt; {
      v.globalOptions = globalOptions;
    });
  });
}

/**
 * Creates the validations class that will become &#x60;model.validations&#x60;.
 *   - Setup parent validation inheritance
 *   - Normalize nested keys (i.e. &#x27;details.dob&#x27;) into objects (i.e { details: { dob: validator() }})
 *   - Merge normalized validations with parent
 *   - Create global CPs (i.e. &#x27;isValid&#x27;, &#x27;messages&#x27;, etc...)
 *
 * @method createValidationsClass
 * @private
 * @param  {Object} inheritedValidationsClass
 * @param  {Object} validations
 * @param  {Object} model
 * @return {Ember.Object}
 */
function createValidationsClass(inheritedValidationsClass, validations, model) {
  let validationRules = {};
  let validatableAttributes = Object.keys(validations);

  // Setup validation inheritance
  if (inheritedValidationsClass &amp;&amp; inheritedValidationsClass.__isCPValidationsClass__) {
    let inheritedValidations = inheritedValidationsClass.create();

    validationRules = merge(validationRules, inheritedValidations.get(&#x27;_validationRules&#x27;));
    validatableAttributes = emberArray(inheritedValidations.get(&#x27;validatableAttributes&#x27;).concat(validatableAttributes)).uniq();
  }

  // Normalize nested keys into actual objects and merge them with parent object
  Object.keys(validations).reduce((obj, key) =&gt; {
    assign(obj, key, validations[key]);
    return obj;
  }, validationRules);

  // Create the mixin that holds all the top level validation props (isValid, messages, etc)
  let TopLevelProps = createTopLevelPropsMixin(validatableAttributes);

  // Create the &#x60;attrs&#x60; class which will add the current model reference once instantiated
  let AttrsClass = createAttrsClass(validatableAttributes, validationRules, model);

  // Create &#x60;validations&#x60; class
  let ValidationsClass = Ember.Object.extend(TopLevelProps, {
    model: null,
    attrs: null,
    isValidations: true,

    validatableAttributes: computed(function() {
      return validatableAttributes;
    }).readOnly(),

    // Caches
    _validators: null,
    _debouncedValidations: null,

    // Private
    _validationRules: computed(function() {
      return validationRules;
    }).readOnly(),

    validate,
    validateSync,
    validateAttribute,

    init() {
      this._super(...arguments);
      this.setProperties({
        attrs: AttrsClass.create({
          _model: this.get(&#x27;model&#x27;)
        }),
        _validators: {},
        _debouncedValidations: {}
      });
    },

    destroy() {
      this._super(...arguments);
      let validatableAttrs = get(this, &#x27;validatableAttributes&#x27;);
      let debouncedValidations = get(this, &#x27;_debouncedValidations&#x27;);

      // Initiate attrs destroy to cleanup any remaining model references
      this.get(&#x27;attrs&#x27;).destroy();

      // Cancel all debounced timers
      validatableAttrs.forEach((attr) =&gt; {
        let attrCache = get(debouncedValidations, attr);

        if (!isNone(attrCache)) {
          // Itterate over each attribute and cancel all of its debounced validations
          Object.keys(attrCache).forEach((v) =&gt; run.cancel(attrCache[v]));
        }
      });
    }
  });

  ValidationsClass.reopenClass({
    __isCPValidationsClass__: true
  });

  return ValidationsClass;
}

/**
 * Creates the &#x60;attrs&#x60; class which holds all the CP logic
 *
 * &#x60;&#x60;&#x60;javascript
 * model.get(&#x27;validations.attrs.username&#x27;);
 * model.get(&#x27;validations.attrs.nested.object.attribute&#x27;);
 * &#x60;&#x60;&#x60;
 *
 * @method createAttrsClass
 * @private
 * @param  {Object} validatableAttributes
 * @param  {Object} validationRules
 * @param  {Object} model
 * @return {Ember.Object}
 */
function createAttrsClass(validatableAttributes, validationRules, model) {
  let nestedClasses = {};
  let rootPath = &#x27;root&#x27;;

  let AttrsClass = Ember.Object.extend({
    __path__: rootPath,

    init() {
      this._super(...arguments);

      let _model = this.get(&#x27;_model&#x27;);
      let path = this.get(&#x27;__path__&#x27;);

      /*
        Instantiate the nested attrs classes for the current path
       */
      Object.keys(nestedClasses[path] || []).forEach((key) =&gt; {
        set(this, key, nestedClasses[path][key].create({
          _model
        }));
      });
    },

    destroy() {
      this._super(...arguments);

      let path = this.get(&#x27;__path__&#x27;);

      /*
        Remove the model reference from each nested class and destroy it
       */
      Object.keys(nestedClasses[path] || []).forEach((key) =&gt; {
        let o = get(this, key);
        o.set(&#x27;_model&#x27;, null);
        o.destroy();
      });
    }
  });

  /*
    Insert CPs + Create nested classes
   */
  validatableAttributes.forEach((attribute) =&gt; {
    let path = attribute.split(&#x27;.&#x27;);
    let attr = path.pop();
    let currPath = [rootPath];
    let currClass = AttrsClass;
    let cpHash = {};

    // Iterate over the path and create the necessary nested classes along the way
    for (let i = 0; i &lt; path.length; i++) {
      let key = path[i];
      let currPathStr = currPath.join(&#x27;.&#x27;);
      let _nestedClasses;

      nestedClasses[currPathStr] = nestedClasses[currPathStr] || {};
      _nestedClasses = nestedClasses[currPathStr];

      currPath.push(key);

      if (!_nestedClasses[key]) {
        _nestedClasses[key] = AttrsClass.extend({
          __path__: currPath.join(&#x27;.&#x27;)
        });
      }

      currClass = _nestedClasses[key];
    }

    // Add the final attr&#x27;s CP to the class
    cpHash[attr] = createCPValidationFor(attribute, model, get(validationRules, attribute));
    currClass.reopen(cpHash);
  });

  return AttrsClass;
}

/**
 * CP generator for the given attribute
 *
 * @method createCPValidationFor
 * @private
 * @param  {String} attribute
 * @param  {Object} model         Since the CPs are created once per class on the first initialization,
 *                                this is the first model that was instantiated
 * @param  {Array} validations
 * @return {Ember.ComputedProperty} A computed property which is a ResultCollection
 */
function createCPValidationFor(attribute, model, validations) {
  let isVolatile = hasOption(validations, &#x27;volatile&#x27;, true);
  let dependentKeys = isVolatile ? [] : getCPDependentKeysFor(attribute, model, validations);

  let cp = computed(...dependentKeys, cycleBreaker(function() {
    let model = get(this, &#x27;_model&#x27;);
    let validators = !isNone(model) ? getValidatorsFor(attribute, model) : [];

    let validationResults = generateValidationResultsFor(attribute, model, validators, (validator, options) =&gt; {
      return validator.validate(validator.getValue(), options, model, attribute);
    });

    return ResultCollection.create({
      attribute,
      content: validationResults
    });
  })).readOnly();

  if (isVolatile) {
    cp = cp.volatile();
  }

  return cp;
}

/**
 * Check if a collection of validations have an option
 * equal to the given value
 *
 * @method hasOption
 * @private
 * @param {Array} validations
 * @param {String} option
 * @param {Boolean} [value=true]
 * @returns {Boolean}
 */
function hasOption(validations, option, value = true) {
  for (let i = 0; i &lt; validations.length; i++) {
    let { options, defaultOptions = {}, globalOptions = {} } = validations[i];
    let mergedOptions = mergeOptions(options, defaultOptions, globalOptions);

    if (mergedOptions[option] === value) {
      return true;
    }
  }

  return false;
}

/**
 * Generates the validation results for a given attribute and validators. If a
 * given validator should be validated, it calls upon the validate callback to retrieve
 * the result.
 *
 * @method generateValidationResultsFor
 * @private
 * @param  {String} attribute
 * @param  {Object} model
 * @param  {Array} validators
 * @param  {Function} validate
 * @param  {Object} opts
 *                    - disableDebounceCache {Boolean}
 * @return {Array}
 */
function generateValidationResultsFor(attribute, model, validators, validate, opts = {}) {
  let isModelValidatable = isValidatable(model);
  let isInvalid = false;
  let value, result;

  return validators.map((validator) =&gt; {
    let _options = get(validator, &#x27;options&#x27;);
    let options = _options.copy();
    let isWarning = getWithDefault(options, &#x27;isWarning&#x27;, false);
    let disabled = getWithDefault(options, &#x27;disabled&#x27;, false);
    let debounce = getWithDefault(options, &#x27;debounce&#x27;, 0);
    let lazy = getWithDefault(options, &#x27;lazy&#x27;, true);

    if (disabled || (lazy &amp;&amp; isInvalid) || !isModelValidatable) {
      value = true;
    } else if (debounce &gt; 0) {
      let cache = getDebouncedValidationsCacheFor(attribute, model);

      // Return a promise and pass the resolve method to the debounce handler
      value = new Promise((resolve) =&gt; {
        let t = run.debounce(validator, resolve, debounce, false);

        if (!opts.disableDebounceCache) {
          cache[guidFor(validator)] = t;
        }
      }).then(() =&gt; {
        return validate(validator, _options.copy());
      });
    } else {
      value = validate(validator, options);
    }

    result = validationReturnValueHandler(attribute, value, model, validator);

    /*
      If the current result is invalid, the rest of the validations do not need to be
      triggered (if lazy) since the attribute is already in an invalid state.
     */
    if (!isInvalid &amp;&amp; !isWarning &amp;&amp; get(result, &#x27;isInvalid&#x27;)) {
      isInvalid = true;
    }

    return result;
  });
}

/**
 * Create a mixin that will have all the top level CPs under the validations object.
 * These are computed collections on different properties of each attribute validations CP
 *
 * @method createTopLevelPropsMixin
 * @private
 * @param  {Object} validations
 */
function createTopLevelPropsMixin(validatableAttrs) {
  // Expose the following properties as public APIs via readOnly aliases
  let aliases = [
    &#x27;isWarning&#x27;,
    &#x27;isValid&#x27;,
    &#x27;isValidating&#x27;,
    &#x27;isDirty&#x27;,
    &#x27;isAsync&#x27;,
    &#x27;isNotValidating&#x27;,
    &#x27;isInvalid&#x27;,
    &#x27;isTruelyValid&#x27;,
    &#x27;messages&#x27;,
    &#x27;message&#x27;,
    &#x27;warningMessages&#x27;,
    &#x27;warningMessage&#x27;,
    &#x27;warnings&#x27;,
    &#x27;warning&#x27;,
    &#x27;errors&#x27;,
    &#x27;error&#x27;,
    &#x27;_promise&#x27;
  ];

  let topLevelProps = aliases.reduce((props, alias) =&gt; {
    props[alias] = computed.readOnly(&#x60;__attrsResultCollection__.${alias}&#x60;);
    return props;
  }, {});

  return Ember.Mixin.create(topLevelProps, {
    /*
      Dedupe logic by creating a top level ResultCollection for all attr&#x27;s ResultCollections
     */
    __attrsResultCollection__: computed(...validatableAttrs.map((attr) =&gt; &#x60;attrs.${attr}&#x60;), function() {
      return ResultCollection.create({
        content: validatableAttrs.map((attr) =&gt; get(this, &#x60;attrs.${attr}&#x60;))
      });
    }).readOnly()
  });
}

/**
 * CP dependency generator for a give attribute depending on its relationships
 *
 * @method getCPDependentKeysFor
 * @private
 * @param  {String} attribute
 * @param  {Object} model         Since the CPs are created once per class on the first initialization,
 *                                this is the first model that was instantiated
 * @param  {Array} validations
 * @return {Array} Unique list of dependencies
 */
function getCPDependentKeysFor(attribute, model, validations) {
  let owner = getOwner(model);

  let dependentKeys = validations.map((validation) =&gt; {
    let { options } = validation;
    let type = validation._type;
    let Validator = type === &#x27;function&#x27; ? BaseValidator : lookupValidator(owner, type);
    let baseDependents = BaseValidator.getDependentsFor(attribute, options) || [];
    let dependents = Validator.getDependentsFor(attribute, options) || [];

    let specifiedDependents = [].concat(
      getWithDefault(options, &#x27;dependentKeys&#x27;, []),
      getWithDefault(validation, &#x27;defaultOptions.dependentKeys&#x27;, []),
      getWithDefault(validation, &#x27;globalOptions.dependentKeys&#x27;, [])
    );

    // Extract dependentKeys from option CPs
    let cpDependents = [].concat(
      extractOptionsDependentKeys(options),
      extractOptionsDependentKeys(get(validation, &#x27;defaultOptions&#x27;)),
      extractOptionsDependentKeys(get(validation, &#x27;globalOptions&#x27;))
    );

    return baseDependents.concat(
      dependents,
      cpDependents,
      specifiedDependents
    );
  });

  dependentKeys = flatten(dependentKeys);

  dependentKeys.push(&#x60;model.${attribute}&#x60;);

  if (isDsModel(model)) {
    dependentKeys.push(&#x60;model.isDeleted&#x60;);
  }

  dependentKeys = dependentKeys.map((d) =&gt; {
    return &#x60;${d.split(&#x27;.&#x27;)[0] === &#x27;model&#x27; ? &#x27;_&#x27; : &#x27;&#x27;}${d}&#x60;;
  });

  return emberArray(dependentKeys).uniq();
}

/**
 * Extract all dependentKeys from any property that is a CP
 *
 * @method extractOptionsDependentKeys
 * @private
 * @param  {Object} options
 * @return {Array}  dependentKeys
 */
function extractOptionsDependentKeys(options) {
  if (options &amp;&amp; typeof options === &#x27;object&#x27;) {
    return Object.keys(options).reduce((arr, key) =&gt; {
      let option = options[key];

      if (option &amp;&amp; typeof option === &#x27;object&#x27; &amp;&amp; option.isDescriptor) {
        return arr.concat(option._dependentKeys || []);
      }

      return arr;
    }, []);
  }

  return [];
}

/**
 * A handler used to create ValidationResult object from values returned from a validator
 *
 * @method validationReturnValueHandler
 * @private
 * @param  {String} attribute
 * @param  {Mixed} value
 * @param  {Object} model
 * @return {ValidationResult}
 */
function validationReturnValueHandler(attribute, value, model, validator) {
  let result;
  let commonProps = {
    model,
    attribute,
    _validator: validator
  };

  if (isPromise(value)) {
    result = ValidationResult.create(commonProps, {
      _promise: Promise.resolve(value)
    });
  } else {
    result = ValidationResult.create(commonProps);
    result.update(value);
  }

  return result;
}

/**
 * Get validators for the give attribute. If they are not in the cache, then create them.
 *
 * @method getValidatorsFor
 * @private
 * @param  {String} attribute
 * @param  {Object} model
 * @return {Array}
 */
function getValidatorsFor(attribute, model) {
  let validators = get(model, &#x60;validations._validators.${attribute}&#x60;);

  if (!isNone(validators)) {
    return validators;
  }

  return createValidatorsFor(attribute, model);
}

/**
 * Get debounced validation cache for the given attribute. If it doesn&#x27;t exist, create a new one.
 *
 * @method getValidatorCacheFor
 * @private
 * @param  {String} attribute
 * @param  {Object} model
 * @return {Map}
 */
function getDebouncedValidationsCacheFor(attribute, model) {
  let debouncedValidations = get(model, &#x27;validations._debouncedValidations&#x27;);

  if (isNone(get(debouncedValidations, attribute))) {
    assign(debouncedValidations, attribute, {});
  }

  return get(debouncedValidations, attribute);
}

/**
 * Create validators for the give attribute and store them in a cache
 *
 * @method createValidatorsFor
 * @private
 * @param  {String} attribute
 * @param  {Object} model
 * @return {Array}
 */
function createValidatorsFor(attribute, model) {
  let validations = get(model, &#x27;validations&#x27;);
  let validationRules = makeArray(get(validations, &#x60;_validationRules.${attribute}&#x60;));
  let validatorCache = get(validations, &#x27;_validators&#x27;);
  let owner = getOwner(model);
  let validators = [];
  let validator;

  // We must have an owner to be able to lookup our validators
  if (isNone(owner)) {
    throw new TypeError(&#x60;[ember-cp-validations] ${model.toString()} is missing a container or owner.&#x60;);
  }

  validationRules.forEach((v) =&gt; {
    v.attribute = attribute;
    v.model = model;

    // If validate function exists, that means validator was created with a function so use the base class
    if (v._type === &#x27;function&#x27;) {
      validator = BaseValidator.create(owner.ownerInjection(), v);
    } else {
      validator = lookupValidator(owner, v._type).create(v);
    }
    validators.push(validator);
  });

  // Add validators to model instance cache
  assign(validatorCache, attribute, validators);

  return validators;
}

/**
 * Lookup a validators of a specific type on the owner
 *
 * @method lookupValidator
 * @throws {Error} Validator not found
 * @private
 * @param  {Ember.Owner} owner
 * @param  {String} type
 * @return {Class} Validator class or undefined if not found
 */
function lookupValidator(owner, type) {
  let validatorClass = owner._lookupFactory(&#x60;validator:${type}&#x60;);

  if (isNone(validatorClass)) {
    throw new Error(&#x60;[ember-cp-validations] Validator not found of type: ${type}.&#x60;);
  }
  return validatorClass;
}

/**
 * ### Options
 * - &#x60;on&#x60; (**Array**): Only validate the given attributes. If empty, will validate over all validatable attribute
 * - &#x60;excludes&#x60; (**Array**): Exclude validation on the given attributes
 *
 * &#x60;&#x60;&#x60;javascript
 * model.validate({ on: [&#x27;username&#x27;, &#x27;email&#x27;] }).then(({ m, validations }) =&gt; {
 *   validations.get(&#x27;isValid&#x27;); // true or false
 *   validations.get(&#x27;isValidating&#x27;); // false
 *
 *   let usernameValidations = m.get(&#x27;validations.attrs.username&#x27;);
 *   usernameValidations.get(&#x27;isValid&#x27;) // true or false
 * });
 * &#x60;&#x60;&#x60;
 *
 * @method validate
 * @param  {Object}  options
 * @param  {Boolean} async      If &#x60;false&#x60;, will get all validations and will error if an async validations is found.
 *                              If &#x60;true&#x60;, will get all validations and wrap them in a promise hash
 * @return {Promise or Object}  Promise if async is true, object if async is false
 */
function validate(options = {}, async = true) {
  let model = get(this, &#x27;model&#x27;);
  let whiteList = makeArray(options.on);
  let blackList = makeArray(options.excludes);

  let validationResults = get(this, &#x27;validatableAttributes&#x27;).reduce((v, name) =&gt; {
    if (!isEmpty(blackList) &amp;&amp; blackList.indexOf(name) !== -1) {
      return v;
    }

    if (isEmpty(whiteList) || whiteList.indexOf(name) !== -1) {
      let validationResult = get(this, &#x60;attrs.${name}&#x60;);

      // If an async validation is found, throw an error
      if (!async &amp;&amp; get(validationResult, &#x27;isAsync&#x27;)) {
        throw new Error(&#x60;[ember-cp-validations] Synchronous validation failed due to ${name} being an async validation.&#x60;);
      }

      v.push(validationResult);
    }
    return v;
  }, []);

  let resultCollection = ResultCollection.create({
    content: validationResults
  });

  let resultObject = {
    model,
    validations: resultCollection
  };

  if (async) {
    if (get(resultCollection, &#x27;isAsync&#x27;)) {
      return RSVP.allSettled(makeArray(get(resultCollection, &#x27;_promise&#x27;))).then(() =&gt; resultObject);
    }
    return Promise.resolve(resultObject);
  }

  return resultObject;
}

/**
 * A functional approach to check if a given attribute on a model is valid independently of the
 * model attribute&#x27;s validations. This method will always return a promise which will then resolve
 * to a {{#crossLink &quot;ResultCollection&quot;}}{{/crossLink}}.
 *
 * &#x60;&#x60;&#x60;javascript
 * model.validateAttribute(&#x27;username&#x27;, &#x27;offirgolan&#x27;).then(({ m, validations }) =&gt; {
 *   validations.get(&#x27;isValid&#x27;); // true or false
 *   validations.get(&#x27;isValidating&#x27;); // false
 * });
 * &#x60;&#x60;&#x60;
 *
 * @method validateAttribute
 * @param  {String}   attribute
 * @param  {Mixed}  value
 * @return {Promise}
 * @async
 */
function validateAttribute(attribute, value) {
  let model = get(this, &#x27;model&#x27;);
  let validators = !isNone(model) ? getValidatorsFor(attribute, model) : [];

  let validationResults = generateValidationResultsFor(attribute, model, validators, (validator, options) =&gt; {
    return validator.validate(value, options, model, attribute);
  }, {
    disableDebounceCache: true
  });

  let validations = ResultCollection.create({
    attribute,
    content: flatten(validationResults)
  });

  let result = { model, validations };

  return Promise.resolve(get(validations, &#x27;isAsync&#x27;) ? get(validations, &#x27;_promise&#x27;).then(() =&gt; result) : result);
}

/**
 * ### Options
 * - &#x60;on&#x60; (**Array**): Only validate the given attributes. If empty, will validate over all validatable attribute
 * - &#x60;excludes&#x60; (**Array**): Exclude validation on the given attributes
 *
 * &#x60;&#x60;&#x60;javascript
 * let { m, validations } = model.validateSync();
 * validations.get(&#x27;isValid&#x27;) // true or false
 * &#x60;&#x60;&#x60;
 *
 * @method validateSync
 * @param  {Object}  options
 * @return {Object}
 */
function validateSync(options) {
  return this.validate(options, false);
}

    </pre>
</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script src="../assets/vendor/prettify/prettify-min.js"></script>
    <script>prettyPrint();</script>
    <script src="../assets/vendor/jquery/jquery.min.js"></script>
    <script src="../assets/vendor/jquery-ui/jquery-ui.min.js"></script>
    <script src="../assets/vendor/bootstrap/js/bootstrap.js"></script>
    <script src="../assets/vendor/github-slugger/slugger.js"></script>
    <script src="../assets/js/yuidoc-bootstrap.js"></script>
</body>
</html>
