{
    "docs": [
        {
            "location": "/index.html", 
            "text": "A Ruby on Rails inspired model validation framework that is completely and utterly computed property based.\n\n\nInstallation\n\n\nember install ember-cp-validations\n\n\n\n\nLive Demo\n\n\nA live demo can be found \nhere\n\n\nBasic Usage - Models\n\n\nThe first thing we need to do it build our validation rules. This will then generate a Mixin that you will be able to incorporate into your model or object.\n\n\n// models/user.js\n\nimport Ember from 'ember';\nimport DS from 'ember-data';\nimport {\n  validator, buildValidations\n}\nfrom 'ember-cp-validations';\n\nvar Validations = buildValidations({\n  username: validator('presence', true),\n  password: [\n    validator('presence', true),\n    validator('length', {\n      min: 4,\n      max: 8\n    })\n  ],\n  email: [\n    validator('presence', true),\n    validator('format', { type: 'email' })\n  ],\n  emailConfirmation: [\n    validator('presence', true),\n    validator('confirmation', {\n      on: 'email',\n      message: 'do not match',\n      description: 'Email addresses'\n    })\n  ]\n});\n\n\n\n\nOnce our rules are created and our Mixin is generated, all we have to do is add it to our model.\n\n\n// models/user.js\n\nexport default DS.Model.extend(Validations, {\n  'username': attr('string'),\n  'password': attr('string'),\n  'email': attr('string')\n});\n\n\n\n\nBasic Usage - Objects\n\n\nYou can also use the generated \nValidations\n mixin on any \nEmber.Object\n or child\nof \nEmber.Object\n, like \nEmber.Component\n. For example:\n\n\n// components/x-foo.js\n\nimport Ember from 'ember';\nimport {\n  validator, buildValidations\n}\nfrom 'ember-cp-validations';\n\nvar Validations = buildValidations({\n  bar: validator('presence', true)\n});\n\nexport default Ember.Component.extend(Validations, {\n  bar: null\n});\n\n\n\n\nTo lookup validators, container access is required which can cause an issue with \nEmber.Object\n creation if the object is statically imported. The current fix for this is as follows. \n\n\n// models/user.js\n\nexport default Ember.Object.extend(Validations, {\n  username: null\n});\n\n\n\n\n// routes/index.js\n\nimport User from '../models/user';\n\nexport default Ember.Route.extend({\n  model() {\n    var container = this.get('container');\n    return User.create({ username: 'John', container })\n  }\n});\n\n\n\n\nAdvanced Usage\n\n\nDefault Options\n\n\nDefault options can be specified over a set of validations for a given attribute. Local properties will always take precedence.\n\n\nInstread of doing the following:\n\n\nvar Validations = buildValidations({\n  username: [\n    validator('presence', {\n      presence: true,\n      description: 'Username'\n    }),\n    validator('length', {\n      min: 1,\n      description: 'Username'\n    }),\n    validator('no-whitespace-around', {\n      description: 'Username'\n    })\n  ]\n});\n\n\n\n\nWe can declare default options: \n\n\nvar Validations = buildValidations({\n  username: {\n    description: 'Username'\n    validators: [\n      validator('presence', true),\n      validator('length', {\n        min: 1\n      }),\n      validator('no-whitespace-around', {\n        description: 'A username'\n      })\n    ]\n  },\n});\n\n\n\n\nIn the above example, all the validators for username will have a description of \nUsername\n except that of the \nno-whitespace-around\n validator which will be \nA username\n.\n\n\nOptions as Functions\n\n\nAll options can be functions which are processed lazily before validate is called. These functions have the context of the validator that is being executed, giving you access to all its properties such as options, model, attribute, etc. \n\n\nPlease note that the \nmessage\n option of a validator has its \nown signature\n.\n\n\nvar Validations = buildValidations({\n  password: validator('format', {\n    description() {\n      return this.get('model.meta.password.description');\n    },\n    regex() {\n      return this.get('model.meta.password.regex');\n    }\n  })\n});", 
            "title": "Home"
        }, 
        {
            "location": "/index.html#installation", 
            "text": "ember install ember-cp-validations", 
            "title": "Installation"
        }, 
        {
            "location": "/index.html#live-demo", 
            "text": "A live demo can be found  here", 
            "title": "Live Demo"
        }, 
        {
            "location": "/index.html#basic-usage-models", 
            "text": "The first thing we need to do it build our validation rules. This will then generate a Mixin that you will be able to incorporate into your model or object.  // models/user.js\n\nimport Ember from 'ember';\nimport DS from 'ember-data';\nimport {\n  validator, buildValidations\n}\nfrom 'ember-cp-validations';\n\nvar Validations = buildValidations({\n  username: validator('presence', true),\n  password: [\n    validator('presence', true),\n    validator('length', {\n      min: 4,\n      max: 8\n    })\n  ],\n  email: [\n    validator('presence', true),\n    validator('format', { type: 'email' })\n  ],\n  emailConfirmation: [\n    validator('presence', true),\n    validator('confirmation', {\n      on: 'email',\n      message: 'do not match',\n      description: 'Email addresses'\n    })\n  ]\n});  Once our rules are created and our Mixin is generated, all we have to do is add it to our model.  // models/user.js\n\nexport default DS.Model.extend(Validations, {\n  'username': attr('string'),\n  'password': attr('string'),\n  'email': attr('string')\n});", 
            "title": "Basic Usage - Models"
        }, 
        {
            "location": "/index.html#basic-usage-objects", 
            "text": "You can also use the generated  Validations  mixin on any  Ember.Object  or child\nof  Ember.Object , like  Ember.Component . For example:  // components/x-foo.js\n\nimport Ember from 'ember';\nimport {\n  validator, buildValidations\n}\nfrom 'ember-cp-validations';\n\nvar Validations = buildValidations({\n  bar: validator('presence', true)\n});\n\nexport default Ember.Component.extend(Validations, {\n  bar: null\n});  To lookup validators, container access is required which can cause an issue with  Ember.Object  creation if the object is statically imported. The current fix for this is as follows.   // models/user.js\n\nexport default Ember.Object.extend(Validations, {\n  username: null\n});  // routes/index.js\n\nimport User from '../models/user';\n\nexport default Ember.Route.extend({\n  model() {\n    var container = this.get('container');\n    return User.create({ username: 'John', container })\n  }\n});", 
            "title": "Basic Usage - Objects"
        }, 
        {
            "location": "/index.html#advanced-usage", 
            "text": "Default Options  Default options can be specified over a set of validations for a given attribute. Local properties will always take precedence.  Instread of doing the following:  var Validations = buildValidations({\n  username: [\n    validator('presence', {\n      presence: true,\n      description: 'Username'\n    }),\n    validator('length', {\n      min: 1,\n      description: 'Username'\n    }),\n    validator('no-whitespace-around', {\n      description: 'Username'\n    })\n  ]\n});  We can declare default options:   var Validations = buildValidations({\n  username: {\n    description: 'Username'\n    validators: [\n      validator('presence', true),\n      validator('length', {\n        min: 1\n      }),\n      validator('no-whitespace-around', {\n        description: 'A username'\n      })\n    ]\n  },\n});  In the above example, all the validators for username will have a description of  Username  except that of the  no-whitespace-around  validator which will be  A username .  Options as Functions  All options can be functions which are processed lazily before validate is called. These functions have the context of the validator that is being executed, giving you access to all its properties such as options, model, attribute, etc.   Please note that the  message  option of a validator has its  own signature .  var Validations = buildValidations({\n  password: validator('format', {\n    description() {\n      return this.get('model.meta.password.description');\n    },\n    regex() {\n      return this.get('model.meta.password.regex');\n    }\n  })\n});", 
            "title": "Advanced Usage"
        }, 
        {
            "location": "/validating/index.html", 
            "text": "Running Manual Validations\n\n\nAlthough validations are lazily computed, there are times where we might want to force all or specific validations to happen. For this reason we have exposed two methods:\n\n\n\n\nvalidateSync\n: Should only be used if all validations are synchronous. It will throw an error if any of the validations are asynchronous\n\n\nvalidate\n: Will always return a promise and should be used if asynchronous validations are present\n\n\n\n\nBoth methods have the same signature:\n\n\nfunction validateSync(options) {}\nfunction validate(options) {}\n\n\n\n\nOptions\n\n\n\n\non\n (\nArray\n): Only validate the given attributes. If empty, will validate over all validatable attribute\n\n\nexcludes\n (\nArray\n): Exclude validation on the given attributes\n\n\n\n\n// Examples\nconst {\n  m,\n  validations\n} = model.validateSync();\nvalidations.get('isValid') // true or false\n\nmodel.validate({\n    on: ['username', 'email']\n}).then(({m, validations}) =\n {\n  validations.get('isValid'); // true or false\n  validations.get('isValidating'); // false\n\n  let usernameValidations = m.get('validations.attrs.username');\n  usernameValidations.get('isValid') // true or false\n});\n\n\n\n\nInspecting Validations\n\n\nAll validations can be accessed via the \nvalidations\n object created on your model/object. Each attribute also has its own validation which has the same properties. An attribute validation can be accessed via \nvalidations.attrs.\nATTRIBUTE\n. If you want to use \nEmber Data's Errors API\n, check out their docs on how to access everything you might need.\n\n\nisValid\n\n\n// Examples\nget(user, 'validations.isValid')\nget(user, 'validations.attrs.username.isValid')\n\n\n\n\nisInvalid\n\n\n// Examples\nget(user, 'validations.isInvalid')\nget(user, 'validations.attrs.username.isInvalid')\n\n\n\n\nisValidating\n\n\nThis property is toggled only if there is an async validation\n\n\n// Examples\nget(user, 'validations.isValidating')\nget(user, 'validations.attrs.username.isValidating')\n\n\n\n\nisTruelyValid\n\n\nWill be true only if isValid is \ntrue\n and isValidating is \nfalse\n\n\n// Examples\nget(user, 'validations.isTruelyValid')\nget(user, 'validations.attrs.username.isTruelyValid')\n\n\n\n\nisDirty\n\n\nWill be true is the attribute in question is not \nnull\n or \nundefined\n. If the object being validated is an Ember Data Model and you have a \ndefaultValue\n specified, then it will use that for comparison.\n\n\n// Examples\n// 'username' : DS.attr('string', { defaultValue: 'johndoe' })\nget(user, 'validations.isDirty')\nget(user, 'validations.attrs.username.isDirty')\n\n\n\n\nisAsync\n\n\nWill be \ntrue\n only if a validation returns a promise\n\n\n// Examples\nget(user, 'validations.isAsync')\nget(user, 'validations.attrs.username.isAsync')\n\n\n\n\nmessages\n\n\nA collection of all error messages on the object in question\n\n\n// Examples\nget(user, 'validations.messages')\nget(user, 'validations.attrs.username.messages')\n\n\n\n\nmessage\n\n\nAn alias to the first message in the messages collection.\n\n\n// Example\nget(user, 'validations.message')\nget(user, 'validations.attrs.username.message')\n\n\n\n\nerrors\n\n\nA collection of all errors on the object in question. Each error object includes the error message and it's associated attribute name.\n\n\n// Example\nget(user, 'validations.errors')\n/* [\n *   {\n *     attribute: 'email'\n *     messages: \nCan't be blank\n\n *   },\n *   {\n *     ...\n *   }\n * ]\n */\n\n\n\n\nerror\n\nAn alias to the first error in the errors collection.\n\n\n// Example\nget(user, 'validations.error')", 
            "title": "Validating"
        }, 
        {
            "location": "/validating/index.html#running-manual-validations", 
            "text": "Although validations are lazily computed, there are times where we might want to force all or specific validations to happen. For this reason we have exposed two methods:   validateSync : Should only be used if all validations are synchronous. It will throw an error if any of the validations are asynchronous  validate : Will always return a promise and should be used if asynchronous validations are present   Both methods have the same signature:  function validateSync(options) {}\nfunction validate(options) {}", 
            "title": "Running Manual Validations"
        }, 
        {
            "location": "/validating/index.html#options", 
            "text": "on  ( Array ): Only validate the given attributes. If empty, will validate over all validatable attribute  excludes  ( Array ): Exclude validation on the given attributes   // Examples\nconst {\n  m,\n  validations\n} = model.validateSync();\nvalidations.get('isValid') // true or false\n\nmodel.validate({\n    on: ['username', 'email']\n}).then(({m, validations}) =  {\n  validations.get('isValid'); // true or false\n  validations.get('isValidating'); // false\n\n  let usernameValidations = m.get('validations.attrs.username');\n  usernameValidations.get('isValid') // true or false\n});", 
            "title": "Options"
        }, 
        {
            "location": "/validating/index.html#inspecting-validations", 
            "text": "All validations can be accessed via the  validations  object created on your model/object. Each attribute also has its own validation which has the same properties. An attribute validation can be accessed via  validations.attrs. ATTRIBUTE . If you want to use  Ember Data's Errors API , check out their docs on how to access everything you might need.  isValid  // Examples\nget(user, 'validations.isValid')\nget(user, 'validations.attrs.username.isValid')  isInvalid  // Examples\nget(user, 'validations.isInvalid')\nget(user, 'validations.attrs.username.isInvalid')  isValidating  This property is toggled only if there is an async validation  // Examples\nget(user, 'validations.isValidating')\nget(user, 'validations.attrs.username.isValidating')  isTruelyValid  Will be true only if isValid is  true  and isValidating is  false  // Examples\nget(user, 'validations.isTruelyValid')\nget(user, 'validations.attrs.username.isTruelyValid')  isDirty  Will be true is the attribute in question is not  null  or  undefined . If the object being validated is an Ember Data Model and you have a  defaultValue  specified, then it will use that for comparison.  // Examples\n// 'username' : DS.attr('string', { defaultValue: 'johndoe' })\nget(user, 'validations.isDirty')\nget(user, 'validations.attrs.username.isDirty')  isAsync  Will be  true  only if a validation returns a promise  // Examples\nget(user, 'validations.isAsync')\nget(user, 'validations.attrs.username.isAsync')  messages  A collection of all error messages on the object in question  // Examples\nget(user, 'validations.messages')\nget(user, 'validations.attrs.username.messages')  message  An alias to the first message in the messages collection.  // Example\nget(user, 'validations.message')\nget(user, 'validations.attrs.username.message')  errors  A collection of all errors on the object in question. Each error object includes the error message and it's associated attribute name.  // Example\nget(user, 'validations.errors')\n/* [\n *   {\n *     attribute: 'email'\n *     messages:  Can't be blank \n *   },\n *   {\n *     ...\n *   }\n * ]\n */  error \nAn alias to the first error in the errors collection.  // Example\nget(user, 'validations.error')", 
            "title": "Inspecting Validations"
        }, 
        {
            "location": "/messages/index.html", 
            "text": "The default validation error messages are imported in your app's \nvalidators\n folder. If you want to change or extend them, all you need to do is create a \nmessages.js\n file under \napp/validators\n.\n\n\n// app/validators/messages.js\n\nimport Messages from 'ember-cp-validations/validators/messages';\n\nexport default Messages.extend({\n  uniqueUsername: '{description} {username} already exists'\n});\n\n\n\n\nWithin this object, you can overwrite the \ndefault messages\n or create new messages just like in the example above. If a message of a given type is not found, it will default to the \ninvalid\n message. Usage examples can be found \nhere\n\n\nCommon Options\n\n\n\n\n_regex\n (\nRegExp\n): Regex for matching error message placeholders\n\n\ndefaultDescription\n (\nString\n): Default attribute description if one isn't passed into a validator's options\n\n\n\n\nMethods\n\n\ngetDescriptionFor (\nString\n)\n\n\nGet a description for a specific attribute. This is a hook for i18n solutions to retrieve attribute descriptions from a translation\n\n\ngetDescriptionFor(attribute, options = {})\n\n\n\n\nattribute\n (\nString\n): Current attribute being evaluated\n\n\noptions\n (\nObject\n): Validator built and processed options \n\n\n\n\ngetMessageFor (\nString\n)\n\n\nGet a message with a given type\n\n\ngetMessageFor(type, context = {})\n\n\n\n\ntype\n (\nString\n): The message type to evaluate (i.e. tooShort, tooLong, etc.)\n\n\ncontext\n (\nObject\n): The context which is used to replace placeholders with their correct values\n\n\n\n\nformatMessage (\nString\n)\n\n\nRegex replace all placeholders with their given context\n\n\nformatMessage(message, context = {})\n\n\n\n\nmessage\n (\nString\n): The message string\n\n\ncontext\n (\nObject\n): The context which is used to replace placeholders with their correct values\n\n\n\n\nI18n Solutions\n\n\n\n\nEmber-Intl\n\n\n\n\nNotice\n: Supports Ember-Intl v2.x and above\n\n\nember install ember-intl-cp-validations\n\n\n\n\nSetup instructions can be found on the \ngithub page\n.\n\n\n\n\nEmber-I18n\n\n\n\n\nember install ember-i18n-cp-validations\n\n\n\n\nSetup instructions can be found on the \ngithub page\n.", 
            "title": "Error Messages"
        }, 
        {
            "location": "/messages/index.html#common-options", 
            "text": "_regex  ( RegExp ): Regex for matching error message placeholders  defaultDescription  ( String ): Default attribute description if one isn't passed into a validator's options", 
            "title": "Common Options"
        }, 
        {
            "location": "/messages/index.html#methods", 
            "text": "getDescriptionFor ( String )  Get a description for a specific attribute. This is a hook for i18n solutions to retrieve attribute descriptions from a translation  getDescriptionFor(attribute, options = {})   attribute  ( String ): Current attribute being evaluated  options  ( Object ): Validator built and processed options    getMessageFor ( String )  Get a message with a given type  getMessageFor(type, context = {})   type  ( String ): The message type to evaluate (i.e. tooShort, tooLong, etc.)  context  ( Object ): The context which is used to replace placeholders with their correct values   formatMessage ( String )  Regex replace all placeholders with their given context  formatMessage(message, context = {})   message  ( String ): The message string  context  ( Object ): The context which is used to replace placeholders with their correct values", 
            "title": "Methods"
        }, 
        {
            "location": "/messages/index.html#i18n-solutions", 
            "text": "Ember-Intl   Notice : Supports Ember-Intl v2.x and above  ember install ember-intl-cp-validations  Setup instructions can be found on the  github page .   Ember-I18n   ember install ember-i18n-cp-validations  Setup instructions can be found on the  github page .", 
            "title": "I18n Solutions"
        }, 
        {
            "location": "/templating/index.html", 
            "text": "Accessing validation information in your templates is really simple but the pathing can be quite long. For example, if we want to display the error \nmessage\n for the \nusername\n attribute, it would look something like this:\n\n\n{{model.validations.attrs.username.message}}\n\n\n\n\nThe V-Get Helper\n\n\nTo bypass such long pathing, you can use the \nv-get\n helper.\n\n\nNotice\n: Ember v1.13.0 is not supported due to a bug. Please use Ember v1.13.1 and higher or Ember v1.12.* and lower\n\n\nAccess global model properties\n\n\n{{v-get model 'isValid'}}\n\n\n\n\nAccess attribute specific properties\n\n\n{{v-get model 'username' 'message'}}\n\n\n\n\nWhat's awesome about this is that you can pass in bound properties!\n\n\n{{v-get model attr prop}}\n{{v-get model prop}}\n\n\n\n\nHere is a more extensive example:\n\n\nform\n\n  {{input value=model.username placeholder=\nUsername\n}}\n  {{#if (v-get model 'username' 'isInvalid')}}\n    \ndiv class=\nerror\n\n      {{v-get model 'username' 'message'}}\n    \n/div\n\n  {{/if}}\n\n  \nbutton type=\nsubmit\n disabled={{v-get model 'isInvalid'}}\nSubmit\n/button\n\n\n/form", 
            "title": "Templating"
        }, 
        {
            "location": "/templating/index.html#the-v-get-helper", 
            "text": "To bypass such long pathing, you can use the  v-get  helper.  Notice : Ember v1.13.0 is not supported due to a bug. Please use Ember v1.13.1 and higher or Ember v1.12.* and lower  Access global model properties  {{v-get model 'isValid'}}  Access attribute specific properties  {{v-get model 'username' 'message'}}  What's awesome about this is that you can pass in bound properties!  {{v-get model attr prop}}\n{{v-get model prop}}  Here is a more extensive example:  form \n  {{input value=model.username placeholder= Username }}\n  {{#if (v-get model 'username' 'isInvalid')}}\n     div class= error \n      {{v-get model 'username' 'message'}}\n     /div \n  {{/if}}\n\n   button type= submit  disabled={{v-get model 'isInvalid'}} Submit /button  /form", 
            "title": "The V-Get Helper"
        }, 
        {
            "location": "/testing/index.html", 
            "text": "When testing any object that uses validators, you have to include them in the \nneeds\n array so they get added to the container. \n\n\nFor example, lets create a simple test for the following \nuser\n model.\n\n\nvar Validations = buildValidations({\n  username: [\n    validator('unique-username'),\n    validator('presence', true)\n  ],\n  password: [\n    validator('presence', true),\n    validator('length', {\n      min: 4,\n      max: 8\n    })\n  ],\n  email: [\n    validator('presence', true),\n    validator('format', {\n      type: 'email'\n    })\n  ]\n});\n\nexport default DS.Model.extend(Validations, {\n  'username': attr('string'),\n  'password': attr('string'),\n  'email': attr('string'),\n});\n\n\n\n\nWhen we define our validations for the model above, we use \n\n\n\n\npresence\n\n\nformat\n\n\nlength\n\n\nunique-username\n - A custom validator\n\n\nmessages\n - The default messages\n\n\n\n\nFor all of those validators to get registered in our testing container, they must be specified in the \nneeds\n array.\n\n\nimport { moduleForModel, test } from 'ember-qunit';\n\nmoduleForModel('user', 'Unit | Model | user', {\n  needs: ['validator:messages', 'validator:presence', 'validator:length', 'validator:format', 'validator:unique-username']\n});\n\ntest('it exists', function(assert) {\n  var model = this.subject();\n  assert.ok(!!model);\n});", 
            "title": "Testing"
        }, 
        {
            "location": "/validators/common/index.html", 
            "text": "description\n\n\nA descriptor for your attribute used in the error message strings. Defaults to \nThis field'\n. You can overwrite this value in your \nvalidators/messages.js\n file by changing the \ndefaultdescription\n property.\n\n\n// Examples\nvalidator('date', {\n    description: 'Date of birth'\n})\n// If validation is run and the attribute is empty, the error returned will be:\n// 'Date of birth can't be blank'\n\n\n\n\ndependentKeys\n\n\nA list of other model specific dependents for you validator.\n\n\n// Examples\nvalidator('has-friends', {\n    dependentKeys: ['friends.[]']\n})\nvalidator('has-valid-friends', {\n    dependentKeys: ['friends.@each.username']\n})\nvalidator('x-validator', {\n    dependentKeys: ['username', 'email', 'meta.foo.bar']\n})\n\n\n\n\nmessage\n\n\nThis option can take two forms. It can either be a \nstring\n or a \nfunction\n. If a string is used, then it will overwrite all error message types for the specified validator.\n\n\n// Example: String\nvalidator('confirmation', {\n  message: 'Email does not match {attribute}. What are you even thinking?!'\n})\n\n\n\n\nWe can pass a \nfunction\n into our message option for even more customization capabilities.\n\n\n// Example: Function\nvalidator('date', {\n  message: function(type, options, value, context) {\n      if (type === 'before') {\n          return '{description} should really be before {date}';\n      }\n      if (type === 'after') {\n          return '{description} should really be after {date}';\n      }\n  }\n})\n\n\n\n\nThe message function is given the following arguments:\n\n\n\n\ntype\n (\nString\n): The error message type\n\n\noptions\n (\nObject\n): The validator options that were defined in the model\n\n\nvalue\n: The current value being evaluated\n\n\ncontext\n (\nObject\n): Context for string replacement\n\n\n\n\nThe return value must be a \nstring\n. If nothing is returned (\nundefined\n), defaults to the default error message of the specified type.\n\n\nWithin this function, the context is set to that of the current validator. This gives you access to the model, defaultMessages, options and more.", 
            "title": "Common Options"
        }, 
        {
            "location": "/validators/common/index.html#description", 
            "text": "A descriptor for your attribute used in the error message strings. Defaults to  This field' . You can overwrite this value in your  validators/messages.js  file by changing the  defaultdescription  property.  // Examples\nvalidator('date', {\n    description: 'Date of birth'\n})\n// If validation is run and the attribute is empty, the error returned will be:\n// 'Date of birth can't be blank'", 
            "title": "description"
        }, 
        {
            "location": "/validators/common/index.html#dependentkeys", 
            "text": "A list of other model specific dependents for you validator.  // Examples\nvalidator('has-friends', {\n    dependentKeys: ['friends.[]']\n})\nvalidator('has-valid-friends', {\n    dependentKeys: ['friends.@each.username']\n})\nvalidator('x-validator', {\n    dependentKeys: ['username', 'email', 'meta.foo.bar']\n})", 
            "title": "dependentKeys"
        }, 
        {
            "location": "/validators/common/index.html#message", 
            "text": "This option can take two forms. It can either be a  string  or a  function . If a string is used, then it will overwrite all error message types for the specified validator.  // Example: String\nvalidator('confirmation', {\n  message: 'Email does not match {attribute}. What are you even thinking?!'\n})  We can pass a  function  into our message option for even more customization capabilities.  // Example: Function\nvalidator('date', {\n  message: function(type, options, value, context) {\n      if (type === 'before') {\n          return '{description} should really be before {date}';\n      }\n      if (type === 'after') {\n          return '{description} should really be after {date}';\n      }\n  }\n})  The message function is given the following arguments:   type  ( String ): The error message type  options  ( Object ): The validator options that were defined in the model  value : The current value being evaluated  context  ( Object ): Context for string replacement   The return value must be a  string . If nothing is returned ( undefined ), defaults to the default error message of the specified type.  Within this function, the context is set to that of the current validator. This gives you access to the model, defaultMessages, options and more.", 
            "title": "message"
        }, 
        {
            "location": "/validators/base/index.html", 
            "text": "All validators extend this base class which have a few important properties and methods that might come of use when creating custom validators.\n\n\nProperties\n\n\n\n\noptions\n (\nObject\n): Options passed in to the validator when defined in the model\n\n\ndefaultOptions\n (\nObject\n): Default validations options for a specific attribute\n\n\nmodel\n (\nObject\n): The model instance\n\n\nattribute\n (\nString\n): Attributed name of the model this validator is attached to\n\n\nerrorMessages\n (\nObject\n): Default error messages. Populated by \nvalidators/messages\n\n\n_type\n (\nString\n): Validator type\n\n\n\n\nMethods\n\n\nbuildOptions (\nObject\n)\n\n\nBuild options hook. Merges default options into options object. This method gets called on init and is the ideal place to normalize your options. The \npresence validator\n is a good example to checkout\n\n\nbuildOptions(options = {}, defaultOptions = {})\n\n\n\n\noptions\n (\nObject\n): Options passed in to the validator when defined in the model\n\n\ndefaultOptions\n (\nObject\n): Default validations options for a specific attribute\n\n\n\n\nprocessOptions (\nObject\n)\n\n\nCreates a new object and calls any option property that is a function with the validator context. This method is called right before \nvalidate\n and the returned object gets passed into the validate method as its options\n\n\nprocessOptions()\n\n\nvalidate\n\n\nThe validate method is where all of your logic should go. It will get passed in the current value of the attribute this validator is attached to. Within the validator object, you will have access to the following properties:\n\n\nvalidate(value, options, model, attribute)\n\n\n\n\nmodel\n (\nModel\n): The current model being validated\n\n\noptions\n (\nObject\n): Validator built and processed options\n\n\nattribute\n (\nString\n): The current attribute being validated\n\n\ndefaultMessages\n(\nObject\n): The default error messages\n\n\n\n\nThe \nvalidate\n method should return one of three types\n\n\n\n\nBoolean\n:  \ntrue\n if the current value passed the validation\n\n\nString\n: The error message\n\n\nPromise\n: A promise that will either resolve or reject, and will finally return either \ntrue\n or the final error message string.\n\n\n\n\ncreateErrorMessage (\nString\n)\n\n\nThis function is used by all pre-defined validators to build an error message that is present in \nvalidators/message\n or decalred in your i18n solution.\n\n\ncreateErrorMessage(type, value, options)\n\n\n\n\ntype\n (\nString\n): The error message type\n\n\nvalue\n: The current value being evaluated\n\n\noptions\n (\nObject\n): Validator built and processed options (used as the message string context)\n\n\n\n\nIf we extended our default messages to include \nuniqueUsername: '{username} already exists'\n, we can use this method to generate our error message.\n\n\nvalidate(value, options) {\n  var exists = false;\n  options.description = 'Username';\n  options.username = value;\n\n  // check with server if username exists...\n\n  if(exists) {\n    return this.createErrorMessage('uniqueUsername', options, value)\n  }\n\n  return true;\n}\n\n\n\n\nIf we input \njohndoe\n and that username already exists, the returned message would be \n'johndoe already exists'\n.", 
            "title": "Base"
        }, 
        {
            "location": "/validators/base/index.html#properties", 
            "text": "options  ( Object ): Options passed in to the validator when defined in the model  defaultOptions  ( Object ): Default validations options for a specific attribute  model  ( Object ): The model instance  attribute  ( String ): Attributed name of the model this validator is attached to  errorMessages  ( Object ): Default error messages. Populated by  validators/messages  _type  ( String ): Validator type", 
            "title": "Properties"
        }, 
        {
            "location": "/validators/base/index.html#methods", 
            "text": "buildOptions ( Object )  Build options hook. Merges default options into options object. This method gets called on init and is the ideal place to normalize your options. The  presence validator  is a good example to checkout  buildOptions(options = {}, defaultOptions = {})   options  ( Object ): Options passed in to the validator when defined in the model  defaultOptions  ( Object ): Default validations options for a specific attribute   processOptions ( Object )  Creates a new object and calls any option property that is a function with the validator context. This method is called right before  validate  and the returned object gets passed into the validate method as its options  processOptions()  validate  The validate method is where all of your logic should go. It will get passed in the current value of the attribute this validator is attached to. Within the validator object, you will have access to the following properties:  validate(value, options, model, attribute)   model  ( Model ): The current model being validated  options  ( Object ): Validator built and processed options  attribute  ( String ): The current attribute being validated  defaultMessages ( Object ): The default error messages   The  validate  method should return one of three types   Boolean :   true  if the current value passed the validation  String : The error message  Promise : A promise that will either resolve or reject, and will finally return either  true  or the final error message string.   createErrorMessage ( String )  This function is used by all pre-defined validators to build an error message that is present in  validators/message  or decalred in your i18n solution.  createErrorMessage(type, value, options)   type  ( String ): The error message type  value : The current value being evaluated  options  ( Object ): Validator built and processed options (used as the message string context)   If we extended our default messages to include  uniqueUsername: '{username} already exists' , we can use this method to generate our error message.  validate(value, options) {\n  var exists = false;\n  options.description = 'Username';\n  options.username = value;\n\n  // check with server if username exists...\n\n  if(exists) {\n    return this.createErrorMessage('uniqueUsername', options, value)\n  }\n\n  return true;\n}  If we input  johndoe  and that username already exists, the returned message would be  'johndoe already exists' .", 
            "title": "Methods"
        }, 
        {
            "location": "/validators/presence/index.html", 
            "text": "If \ntrue\n validates that the given value is not empty, if \nfalse\n, validates that the given value is empty.\n\n\n// Examples\nvalidator('presence', true)\nvalidator('presence', false)\nvalidator('presence', {\n  presence: true,\n  message: 'should not be empty'\n})", 
            "title": "Presence"
        }, 
        {
            "location": "/validators/inclusion/index.html", 
            "text": "Validates that the attributes\u2019 values are included in a given list. All comparisons are done using strict equality so type matters! For range, the value type is checked against both lower and upper bounds for type equality.\n\n\nOptions\n\n\n\n\nallowBlank\n (\nBoolean\n): If true, skips validation if the value is empty\n\n\nin\n (\nArray\n): The list of values this attribute could be\n\n\nrange\n (\nArray\n): The range in which the attribute's value should reside in\n\n\n\n\n// Examples\nvalidator('inclusion', {\n    in: ['User', 'Admin']\n})\nvalidator('inclusion', {\n    range: [0, 5] // Must be between 0 (inclusive) to 5 (inclusive)\n})\n\n\n\n\nBecause of the strict equality comparisons, you can use this validator in many different ways.\n\n\n// Examples\nvalidator('inclusion', {\n    in: ['Admin'] // Input must be equal to 'Admin'\n})\nvalidator('inclusion', {\n    range: [0, Infinity] // Input must be positive number\n})\nvalidator('inclusion', {\n    range: [-Infinity, Infinity] // Input must be a number\n})", 
            "title": "Inclusion"
        }, 
        {
            "location": "/validators/inclusion/index.html#options", 
            "text": "allowBlank  ( Boolean ): If true, skips validation if the value is empty  in  ( Array ): The list of values this attribute could be  range  ( Array ): The range in which the attribute's value should reside in   // Examples\nvalidator('inclusion', {\n    in: ['User', 'Admin']\n})\nvalidator('inclusion', {\n    range: [0, 5] // Must be between 0 (inclusive) to 5 (inclusive)\n})  Because of the strict equality comparisons, you can use this validator in many different ways.  // Examples\nvalidator('inclusion', {\n    in: ['Admin'] // Input must be equal to 'Admin'\n})\nvalidator('inclusion', {\n    range: [0, Infinity] // Input must be positive number\n})\nvalidator('inclusion', {\n    range: [-Infinity, Infinity] // Input must be a number\n})", 
            "title": "Options"
        }, 
        {
            "location": "/validators/exclusion/index.html", 
            "text": "Validates that the attributes\u2019 values are not included in a given list. All comparisons are done using strict equality so type matters! For range, the value type is checked against both lower and upper bounds for type equality.\n\n\nOptions\n\n\n\n\nallowBlank\n (\nBoolean\n): If true, skips validation if the value is empty\n\n\nin\n (\nArray\n): The list of values this attribute should not be\n\n\nrange\n (\nArray\n): The range in which the attribute's value should not reside in\n\n\n\n\n// Examples\nvalidator('exclusion', {\n    in: ['Admin', 'Super Admin']\n})\nvalidator('exclusion', {\n    range: [0, 5] // Cannot be between 0 (inclusive) to 5 (inclusive)\n})", 
            "title": "Exclusion"
        }, 
        {
            "location": "/validators/exclusion/index.html#options", 
            "text": "allowBlank  ( Boolean ): If true, skips validation if the value is empty  in  ( Array ): The list of values this attribute should not be  range  ( Array ): The range in which the attribute's value should not reside in   // Examples\nvalidator('exclusion', {\n    in: ['Admin', 'Super Admin']\n})\nvalidator('exclusion', {\n    range: [0, 5] // Cannot be between 0 (inclusive) to 5 (inclusive)\n})", 
            "title": "Options"
        }, 
        {
            "location": "/validators/length/index.html", 
            "text": "Validates the length of the attributes\u2019 values.\n\n\nOptions\n\n\n\n\nallowBlank\n (\nBoolean\n): If true, skips validation if the value is empty\n\n\nis\n (\nNumber\n): The exact length the value can be\n\n\nmin\n (\nNumber\n): The minimum length the value can be\n\n\nmax\n (\nNumber\n): The maximum length the value can be\n\n\n\n\n// Examples\nvalidator('length', {\n  is: 15\n})\nvalidator('length', {\n    min: 5,\n    max: 10\n})", 
            "title": "Length"
        }, 
        {
            "location": "/validators/length/index.html#options", 
            "text": "allowBlank  ( Boolean ): If true, skips validation if the value is empty  is  ( Number ): The exact length the value can be  min  ( Number ): The minimum length the value can be  max  ( Number ): The maximum length the value can be   // Examples\nvalidator('length', {\n  is: 15\n})\nvalidator('length', {\n    min: 5,\n    max: 10\n})", 
            "title": "Options"
        }, 
        {
            "location": "/validators/number/index.html", 
            "text": "Validates that your attributes have only numeric values.\n\n\nOptions\n\n\n\n\nallowString\n (\nBoolean\n): If true, validator will accept string representation of a number\n\n\ninteger\n (\nBoolean\n): Number must be an integer\n\n\npositive\n (\nBoolean\n): Number must be greater than 0\n\n\nodd\n (\nBoolean\n): Number must be odd\n\n\neven\n (\nBoolean\n): Number must be even\n\n\nis\n (\nNumber\n): Number must be equal to this value\n\n\nlt\n (\nNumber\n): Number must be less than this value\n\n\nlte\n (\nNumber\n): Number must be less than or equal to this value\n\n\ngt\n (\nNumber\n): Number must be greater than this value\n\n\ngte\n (\nNumber\n): Number must be greater than or equal to this value\n\n\n\n\n// Examples\nvalidator('number') // Simple check if the value is a number\nvalidator('number', {\n    allowString: true,\n    integer: true,\n    gt: 5,\n    lte: 100\n})", 
            "title": "Number"
        }, 
        {
            "location": "/validators/number/index.html#options", 
            "text": "allowString  ( Boolean ): If true, validator will accept string representation of a number  integer  ( Boolean ): Number must be an integer  positive  ( Boolean ): Number must be greater than 0  odd  ( Boolean ): Number must be odd  even  ( Boolean ): Number must be even  is  ( Number ): Number must be equal to this value  lt  ( Number ): Number must be less than this value  lte  ( Number ): Number must be less than or equal to this value  gt  ( Number ): Number must be greater than this value  gte  ( Number ): Number must be greater than or equal to this value   // Examples\nvalidator('number') // Simple check if the value is a number\nvalidator('number', {\n    allowString: true,\n    integer: true,\n    gt: 5,\n    lte: 100\n})", 
            "title": "Options"
        }, 
        {
            "location": "/validators/date/index.html", 
            "text": "Validate over a date range. Uses \nMomentJS\n for date mathematics and calculations.\n\n\nNote\n: MomentJS must be installed to be able to use this validator. The easiest way to do this is to install \nember-moment\n\n\nOptions\n\n\n\n\nallowBlank\n (\nBoolean\n): If true, skips validation if the value is empty\n\n\nbefore\n (\nString\n): The specified date must be before this date\n\n\nafter\n (\nString\n): The specified date must be after this date\n\n\nformat\n (\nString\n): Input value date format\n\n\nerrorFormat\n (\nString\n): Error output date format. Defaults to \nMMM Do, YYYY\n\n\n\n\n// Example\nvalidator('date', {\n    after: 'now',\n    before: '1/1/2020',\n    format: 'M/D/YYY',\n    errorFormat: 'M/D/YYY'\n})\n// If before or after is set to 'now', the value given to the validator will be tested against the current date and time.", 
            "title": "Date"
        }, 
        {
            "location": "/validators/date/index.html#options", 
            "text": "allowBlank  ( Boolean ): If true, skips validation if the value is empty  before  ( String ): The specified date must be before this date  after  ( String ): The specified date must be after this date  format  ( String ): Input value date format  errorFormat  ( String ): Error output date format. Defaults to  MMM Do, YYYY   // Example\nvalidator('date', {\n    after: 'now',\n    before: '1/1/2020',\n    format: 'M/D/YYY',\n    errorFormat: 'M/D/YYY'\n})\n// If before or after is set to 'now', the value given to the validator will be tested against the current date and time.", 
            "title": "Options"
        }, 
        {
            "location": "/validators/format/index.html", 
            "text": "Validate over a predefined or custom regular expression.\n\n\nOptions\n\n\n\n\nallowBlank\n (\nBoolean\n): If true, skips validation if the value is empty\n\n\ntype\n (\nString\n): Can be the one of the following options [\nemail\n, \nphone\n, \nurl\n]\n\n\nregex\n (\nRegExp\n): The regular expression to test against\n\n\n\n\n// Examples\nvalidator('format', {\n  type: 'email'\n})\nvalidator('format', {\n  allowBlank: true\n  type: 'phone'\n})\nvalidator('format', {\n  type: 'url'\n})\nvalidator('format', {\n    regex: /^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{4,8}$/,\n    message: 'Password must include at least one upper case letter, one lower case letter, and a number'\n})\n\n\n\n\nIf you do not want to use the predefined regex for a specific type, you can do something like this\n\n\n// Example\nvalidator('format', {\n  type: 'email',\n  regex: /My Better Email Regexp/\n})\n\n\n\n\nThis allows you to still keep the email error message but with your own custom regex.", 
            "title": "Format"
        }, 
        {
            "location": "/validators/format/index.html#options", 
            "text": "allowBlank  ( Boolean ): If true, skips validation if the value is empty  type  ( String ): Can be the one of the following options [ email ,  phone ,  url ]  regex  ( RegExp ): The regular expression to test against   // Examples\nvalidator('format', {\n  type: 'email'\n})\nvalidator('format', {\n  allowBlank: true\n  type: 'phone'\n})\nvalidator('format', {\n  type: 'url'\n})\nvalidator('format', {\n    regex: /^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{4,8}$/,\n    message: 'Password must include at least one upper case letter, one lower case letter, and a number'\n})  If you do not want to use the predefined regex for a specific type, you can do something like this  // Example\nvalidator('format', {\n  type: 'email',\n  regex: /My Better Email Regexp/\n})  This allows you to still keep the email error message but with your own custom regex.", 
            "title": "Options"
        }, 
        {
            "location": "/validators/dependent/index.html", 
            "text": "Defines an attribute as valid only if its dependents are valid.\n\n\nOptions\n\n\n\n\non\n (\nArray\n): Attributes this field is dependent on\n\n\n\n\n// Example\n// Full name will only be valid if firstName and lastName are filled in\nvalidator('dependent', {\n    on: ['firstName', 'lastName'],\n})", 
            "title": "Dependent"
        }, 
        {
            "location": "/validators/dependent/index.html#options", 
            "text": "on  ( Array ): Attributes this field is dependent on   // Example\n// Full name will only be valid if firstName and lastName are filled in\nvalidator('dependent', {\n    on: ['firstName', 'lastName'],\n})", 
            "title": "Options"
        }, 
        {
            "location": "/validators/confirmation/index.html", 
            "text": "You should use this validator when you have two text fields that should receive exactly the same content. For example, you may want to confirm an email address or a password. This validator doesnt have to be created on an attribute defined in your model. This means that when you save your model, in this case, \nverfiedEmail\n will not be part of the payload.\n\n\n// Example\nemail: validator('format', {\n  type: 'email'\n})\nverifiedEmail: validator('confirmation', {\n    on: 'email'\n    message: 'do not match'\n    description: 'Email addresses'\n})", 
            "title": "Confirmation"
        }, 
        {
            "location": "/validators/collection/index.html", 
            "text": "If \ntrue\n validates that the given value is a valid collection and will add \nATTRIUTE\n.[]\n as a dependent key to the CP. If \nfalse\n, validates that the given value is singular. Use this validator if you want validation to occur when the content of your collection changes.\n\n\n// Examples\nvalidator('collection', true)\nvalidator('collection', false)\nvalidator('collection', {\n  collection: true,\n  message: 'must be a collection'\n})", 
            "title": "Collection"
        }, 
        {
            "location": "/validators/belongs-to/index.html", 
            "text": "Identifies a \nbelongs-to\n relationship in an Ember Data Model. This is used to create a link to the validations object of the child model.\n\n\nNote:\n Validations must exist on \nboth\n models\n \n\n\n// model/users.js\n\nvar Validations = buildValidations({\n  details: validator('belongs-to')\n});\n\nexport default DS.Model.extend(Validations, {\n  'details': DS.belongsTo('user-detail')\n});\n\n\n\n\n// model/user-details.js\n\nvar Validations = buildValidations({\n  firstName: validator('presence', true),\n  lastName: validator('presence', true)\n});\n\nexport default DS.Model.extend(Validations, {\n  \nfirstName\n: attr('string'),\n  \nlastName\n: attr('string'),\n});\n\n\n\n\nFrom our \nuser\n model, we can now check any validation propery on the \nuser-details\n model.\n\n\nget(model, 'validations.attrs.details.isValid')\nget(model, 'validations.attrs.details.messages')", 
            "title": "Belongs To"
        }, 
        {
            "location": "/validators/has-many/index.html", 
            "text": "Identifies a \nhas-many\n relationship in an Ember Data Model. This is used to create a validation collection of the \nhas-many\n validations.\n\n\nNote:\n Validations must exist on \nall\n models\n \n\n\n// model/users.js\n\nvar Validations = buildValidations({\n  friends: validator('has-many')\n});\n\nexport default DS.Model.extend(Validations, {\n  'friends': DS.hasMany('user')\n});\n\n\n\n\nFrom our \nuser\n model, we can now check validation properties on the \nfriends\n attribute.\n\n\nget(model, 'validations.attrs.friends.isValid')\nget(model, 'validations.attrs.friends.messages')", 
            "title": "Has Many"
        }, 
        {
            "location": "/validators/function/index.html", 
            "text": "A validator can also be declared with a function. The function will be then wrapped in the \nBase Validator\n class and used just like any other pre-defined validator.\n\n\n// Example\nvalidator(function(value, options /*, model, attribute*/) {\n  return value === options.username ? true : `must be ${options.username}`;\n} , {\n    username: 'John' // Any options can be passed here\n})", 
            "title": "Function"
        }, 
        {
            "location": "/validators/custom/index.html", 
            "text": "Creating custom validators is very simple. To generate a validator named \nunique-username\n in Ember CLI\n\n\nember generate validator unique-username\n\n\n\n\nThis will create the following files\n\n\n\n\napp/validators/unique-username.js\n\n\ntests/unit/validators/unique-username-test.js\n\n\n\n\n// app/validators/unique-username.js\n\nimport Ember from 'ember';\nimport BaseValidator from 'ember-cp-validations/validators/base';\n\nexport default BaseValidator.extend({\n  validate(value, options /*, model, attribute*/) {\n    return true;\n    })\n  }\n});\n\n\n\n\nSide Node\n: Before we continue, I would suggest checking out the documentation for the \nBaseValidator\n.\n\n\nIf you want to interact with the \nstore\n within your validator, you can simply inject the service like you would a component. Since you have access to your model and the current value, you should be able to send the server the right information to determine if this username is unique.\n\n\n// app/validators/unique-username.js\n\nimport Ember from 'ember';\nimport BaseValidator from 'ember-cp-validations/validators/base';\n\nexport default BaseValidator.extend({\n  store: Ember.inject.service(),\n\n  validate(value, options /*, model, attribute*/) {\n    return this.get('store').findRecord('user', value).then((user) =\n {\n      if(user \n user.id === value) {\n        let message = `The username '${value}' already exists.`;\n        let meta = user.get('meta');\n\n        if(options.showSuggestions \n meta \n meta.suggestions) {\n          message += \nWhat about one of the these: \n + meta.suggestions.join(', ');\n        }\n        return message;\n      } else {\n        return true;\n      }\n    })\n  }\n});\n\n\n\n\nTo use our unique-username validator we just have to add it to the model definition\n\n\nvar Validations = buildValidations({\n  username: validator('unique-username', {\n    showSuggestions: true\n  }),\n});\n\nexport default DS.Model.extend(Validations, {\n  'username': DS.attr('string'),\n});\n\n\n\n\nTesting\n\n\nAs mentioned before, the generator created a unit test for your new custom validator.\n\n\n// tests/unit/validators/unique-username-test.js\n\nimport Ember from 'ember';\nimport { moduleFor, test } from 'ember-qunit';\n\nmoduleFor('validator:unique-username', 'Unit | Validator | unique-username', {\n    needs: ['validator:messages']\n});\n\ntest('it works', function(assert) {\n    var validator =  this.subject();\n    assert.ok(validator);\n});\n\n\n\n\nA simple test for our validation method can be as such\n\n\ntest('username is unique', function(assert) {\n    assert.expect(1);\n\n    let validator =  this.subject();\n    let done = assert.async();\n\n    validator.validate('johndoe42').then((message) =\n {\n      assert.equal(message, true);\n      done();\n    });\n});", 
            "title": "Custom"
        }, 
        {
            "location": "/validators/custom/index.html#testing", 
            "text": "As mentioned before, the generator created a unit test for your new custom validator.  // tests/unit/validators/unique-username-test.js\n\nimport Ember from 'ember';\nimport { moduleFor, test } from 'ember-qunit';\n\nmoduleFor('validator:unique-username', 'Unit | Validator | unique-username', {\n    needs: ['validator:messages']\n});\n\ntest('it works', function(assert) {\n    var validator =  this.subject();\n    assert.ok(validator);\n});  A simple test for our validation method can be as such  test('username is unique', function(assert) {\n    assert.expect(1);\n\n    let validator =  this.subject();\n    let done = assert.async();\n\n    validator.validate('johndoe42').then((message) =  {\n      assert.equal(message, true);\n      done();\n    });\n});", 
            "title": "Testing"
        }
    ]
}